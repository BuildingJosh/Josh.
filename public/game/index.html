<!DOCTYPE html>
<html>
<head>
    <title>Kill-em</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: #000;
            height: 100vh;
            font-family: "Courier New", monospace;
        }
        #loadingScreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: #000;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            color: #0f0;
            text-align: center;
        }
        #loadingTitle {
            font-size: 72px;
            margin-bottom: 20px;
            text-shadow: 0 0 10px #0f0;
            animation: glow 2s ease-in-out infinite;
        }
        #startButton {
            font-size: 24px;
            padding: 15px 30px;
            background-color: transparent;
            border: 2px solid #0f0;
            color: #0f0;
            cursor: pointer;
            transition: all 0.3s;
            font-family: "Courier New", monospace;
            margin-top: 20px;
            text-transform: uppercase;
        }
        #startButton:hover {
            background-color: #0f0;
            color: #000;
        }
        #gameContainer {
            display: none;
            position: relative;
        }
        @keyframes glow {
            0% { text-shadow: 0 0 10px #0f0; }
            50% { text-shadow: 0 0 20px #0f0, 0 0 30px #0f0; }
            100% { text-shadow: 0 0 10px #0f0; }
        }
        canvas {
            border: 2px solid #0f0;
        }
        #hud {
            position: absolute;
            top: 20px;
            left: 20px;
            color: #0f0;
            font-family: "Courier New", monospace;
            background-color: rgba(0, 32, 0, 0.7);
            padding: 15px;
            border-radius: 5px;
            border: 1px solid #0f0;
            font-size: 16px;
            text-transform: uppercase;
        }
        #healthContainer {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 200px;
            background-color: rgba(0, 32, 0, 0.7);
            padding: 10px;
            border-radius: 5px;
            border: 1px solid #0f0;
        }
        #healthLabel {
            color: #0f0;
            font-family: "Courier New", monospace;
            margin-bottom: 5px;
            text-align: center;
            text-transform: uppercase;
        }
        #healthBar {
            width: 100%;
            height: 20px;
            border: 2px solid #0f0;
            background-color: #800000;
        }
        #healthFill {
            width: 100%;
            height: 100%;
            background-color: #00ff00;
            transition: width 0.3s;
        }
        #timer {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: #0f0;
            font-family: "Courier New", monospace;
            font-size: 24px;
            background-color: rgba(0, 32, 0, 0.7);
            padding: 10px 20px;
            border-radius: 5px;
            border: 1px solid #0f0;
            text-transform: uppercase;
        }
        #radar {
            position: absolute;
            bottom: 20px;
            right: 20px;
            border: 2px solid #0f0;
            border-radius: 5px;
            background-color: rgba(0, 32, 0, 0.7);
        }
        #gameOver, #levelComplete {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #f00;
            font-family: "Courier New", monospace;
            font-size: 48px;
            text-align: center;
            background-color: rgba(0, 0, 0, 0.8);
            padding: 20px;
            border-radius: 10px;
            display: none;
        }
        #levelComplete {
            color: #0f0;
        }
        #leaderboard {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 32, 0, 0.9);
            padding: 20px;
            border-radius: 10px;
            color: #90EE90;
            display: none;
            text-align: center;
            border: 2px solid #50C878;
            box-shadow: 0 0 20px rgba(0, 255, 0, 0.2);
            min-width: 400px;
        }
        #leaderboard h2 {
            color: #7FFF00;
            text-shadow: 0 0 10px rgba(0, 255, 0, 0.3);
            font-size: 28px;
            margin-bottom: 20px;
        }
        #leaderboard table {
            width: 100%;
            margin-top: 20px;
            border-collapse: collapse;
            color: #98FB98;
        }
        #leaderboard th, #leaderboard td {
            padding: 8px;
            border-bottom: 1px solid #006400;
        }
        #leaderboard th {
            color: #7FFF00;
            font-size: 18px;
            text-transform: uppercase;
        }
        #leaderboard tr:hover {
            background: rgba(0, 100, 0, 0.3);
        }
        #leaderboard input {
            background: #004d00;
            border: 2px solid #00FF00;
            padding: 10px;
            color: #90EE90;
            text-transform: uppercase;
            text-align: center;
            width: 100px;
            margin: 10px 0;
            font-size: 24px;
            border-radius: 5px;
        }
        #leaderboard input:focus {
            outline: none;
            border-color: #7FFF00;
            box-shadow: 0 0 10px rgba(0, 255, 0, 0.5);
        }
        #leaderboard button {
            background: #006400;
            border: none;
            padding: 12px 24px;
            color: #90EE90;
            cursor: pointer;
            margin: 10px;
            border-radius: 5px;
            font-size: 16px;
            text-transform: uppercase;
            transition: all 0.3s ease;
        }
        #leaderboard button:hover {
            background: #008000;
            box-shadow: 0 0 15px rgba(0, 255, 0, 0.4);
            transform: translateY(-2px);
        }
        #finalScore, #finalLevel {
            color: #7FFF00;
            font-size: 24px;
            font-weight: bold;
            text-shadow: 0 0 10px rgba(0, 255, 0, 0.3);
        }
    </style>
</head>
<body>
    <div id="loadingScreen">
        <div id="loadingTitle">KILL-EM</div>
        <div style="font-size: 24px; margin: 20px 0;">
            CONTROLS:<br>
            W - UP<br>
            S - DOWN<br>
            A - LEFT<br>
            D - RIGHT<br>
            AVOID MISSILES<br>
            POP BALLOONS
        </div>
        <button id="startButton">START MISSION</button>
    </div>

    <div id="gameContainer">
        <div id="hud">
            SCORE: <span id="score">0</span><br>
            LEVEL: <span id="level">1</span>/5
        </div>
        <div id="timer">TIME: <span id="time">30</span>s</div>
        <div id="healthContainer">
            <div id="healthLabel">HEALTH</div>
            <div id="healthBar">
                <div id="healthFill"></div>
            </div>
        </div>
        <div id="levelComplete">
            LEVEL COMPLETE!<br>
            <span style="font-size: 24px">Get Ready for Level <span id="nextLevel">2</span></span>
        </div>
        <div id="gameOver">
            MISSION FAILED<br>
            <span style="font-size: 24px">Final Score: <span id="finalScore">0</span><br>Press SPACE to restart</span>
        </div>
        <canvas id="gameCanvas"></canvas>
        <canvas id="radar"></canvas>
    </div>

    <div id="leaderboard">
        <h2>Game Over!</h2>
        <p>Score: <span id="finalScore">0</span></p>
        <p>Level: <span id="finalLevel">1</span></p>
        <input type="text" id="initials" maxlength="3" placeholder="AAA">
        <br>
        <button onclick="submitScore()">Submit Score</button>
        <button onclick="restartGame()">Play Again</button>
        <table>
            <thead>
                <tr>
                    <th>Rank</th>
                    <th>Player</th>
                    <th>Score</th>
                    <th>Level</th>
                </tr>
            </thead>
            <tbody id="scoresTable"></tbody>
        </table>
    </div>

    <script>
        // Get DOM elements
        const loadingScreen = document.getElementById('loadingScreen');
        const startButton = document.getElementById('startButton');
        const gameContainer = document.getElementById('gameContainer');
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const radarCanvas = document.getElementById('radar');
        const radarCtx = radarCanvas.getContext('2d');
        const scoreDisplay = document.getElementById('score');
        const levelDisplay = document.getElementById('level');
        const timeDisplay = document.getElementById('time');
        const heightDisplay = document.getElementById('height');

        // Set canvas sizes
        canvas.width = 1200;
        canvas.height = 800;
        radarCanvas.width = 200;
        radarCanvas.height = 200;

        // Game state
        let state = null;

        // Initialize game state
        function createInitialState() {
            return {
                score: 0,
                level: 1,
                gameOver: false,
                levelComplete: false,
                timeRemaining: 30,
                lastTime: Date.now(),
                keys: {},
                plane: {
                    x: canvas.width / 2,
                    y: canvas.height / 2,
                    targetY: canvas.height / 2,
                    targetX: canvas.width / 2,
                    height: 1000,
                    rotation: 0,
                    speed: 15,
                    health: 100
                },
                balloons: [],
                missiles: [],
                terrain: [],
                clouds: Array.from({ length: 15 }, () => ({
                    x: Math.random() * canvas.width,
                    y: Math.random() * (canvas.height / 2),
                    speed: 2 + Math.random(),
                    size: 50 + Math.random() * 100
                })),
                gameSpeed: 4,
                effects: [],
                missileSpawnTimer: 0
            };
        }

        // Reset game state
        function resetGame() {
            state = createInitialState();
            state.terrain = generateTerrain();
            
            // Reset UI
            scoreDisplay.textContent = '0';
            levelDisplay.textContent = '1';
            timeDisplay.textContent = '30';
            document.getElementById('healthFill').style.width = '100%';
            document.getElementById('gameOver').style.display = 'none';
            document.getElementById('levelComplete').style.display = 'none';

            // Spawn initial balloons
            const config = levelConfig[state.level];
            for (let i = 0; i < config.balloonCount; i++) {
                spawnBalloon();
            }
        }

        // Level configuration
        const levelConfig = {
            1: { balloonCount: 5, missileInterval: 120, missileCount: 2 },  // 2 missiles every 2 seconds
            2: { balloonCount: 7, missileInterval: 110, missileCount: 3 },  // 3 missiles, slightly faster
            3: { balloonCount: 10, missileInterval: 100, missileCount: 4 }, // 4 missiles, faster
            4: { balloonCount: 12, missileInterval: 90, missileCount: 5 },  // 5 missiles, even faster
            5: { balloonCount: 15, missileInterval: 80, missileCount: 6 }   // 6 missiles, super fast
        };

        // Missile class
        class Missile {
            constructor(x, y, index) {
                this.x = x;
                this.y = y;
                
                // Calculate spread based on missile index
                const spreadAngle = 0.4; // Total spread angle in radians
                const dx = state.plane.x - x;
                const dy = state.plane.y - y;
                const baseAngle = Math.atan2(dy, dx);
                
                // Distribute missiles evenly across the spread
                const missileCount = levelConfig[state.level].missileCount;
                const angleStep = spreadAngle / (missileCount - 1);
                const finalAngle = baseAngle - (spreadAngle / 2) + (angleStep * index);
                
                // Set velocity based on angle
                const speed = 8 + (state.level - 1); // Increase speed with level
                this.vx = Math.cos(finalAngle) * speed;
                this.vy = Math.sin(finalAngle) * speed;
                this.rotation = finalAngle;
                this.active = true;
                this.warning = true;
                this.warningTime = 60;
                this.trailPoints = [];  // Store trail points
            }

            update() {
                if (this.warning) {
                    this.warningTime--;
                    if (this.warningTime <= 0) {
                        this.warning = false;
                    }
                    return;
                }

                // Store trail point
                this.trailPoints.push({x: this.x, y: this.y});
                if (this.trailPoints.length > 10) {
                    this.trailPoints.shift();
                }

                this.x += this.vx;
                this.y += this.vy;

                // Deactivate if off screen
                if (this.x < -50 || this.x > canvas.width + 50 ||
                    this.y < -50 || this.y > canvas.height + 50) {
                    this.active = false;
                }

                // Check collision with plane
                const dx = this.x - state.plane.x;
                const dy = this.y - state.plane.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                if (distance < 30) {  
                    this.active = false;
                    damagePlayer(25);  
                    createExplosion(this.x, this.y);
                }
            }

            draw() {
                if (!this.active) return;

                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.rotation);

                if (this.warning) {
                    // Warning indicator
                    ctx.strokeStyle = '#ff0000';
                    ctx.lineWidth = 2;
                    ctx.setLineDash([5, 5]);
                    ctx.beginPath();
                    ctx.moveTo(-20, 0);
                    ctx.lineTo(20, 0);
                    ctx.stroke();
                    ctx.setLineDash([]);
                } else {
                    // Draw missile trail
                    if (this.trailPoints.length > 1) {
                        ctx.save();
                        ctx.resetTransform();  // Reset transform for trail
                        
                        // Draw smoke trail
                        ctx.strokeStyle = '#666';
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        for (let i = 0; i < this.trailPoints.length - 1; i++) {
                            const point = this.trailPoints[i];
                            const nextPoint = this.trailPoints[i + 1];
                            if (i === 0) {
                                ctx.moveTo(point.x, point.y);
                            }
                            ctx.lineTo(nextPoint.x, nextPoint.y);
                        }
                        ctx.stroke();

                        // Draw fire trail
                        const gradient = ctx.createLinearGradient(
                            this.trailPoints[0].x, this.trailPoints[0].y,
                            this.x, this.y
                        );
                        gradient.addColorStop(0, 'rgba(255, 69, 0, 0)');
                        gradient.addColorStop(1, 'rgba(255, 69, 0, 0.5)');
                        ctx.strokeStyle = gradient;
                        ctx.lineWidth = 3;
                        ctx.stroke();
                        
                        ctx.restore();
                    }

                    // Draw missile body
                    ctx.fillStyle = '#666';
                    ctx.beginPath();
                    ctx.moveTo(15, 0);  // Nose
                    ctx.lineTo(5, -3);   // Body
                    ctx.lineTo(-15, -3);
                    ctx.lineTo(-15, 3);
                    ctx.lineTo(5, 3);
                    ctx.closePath();
                    ctx.fill();

                    // Draw fins
                    ctx.beginPath();
                    ctx.moveTo(-10, 0);  // Fin attachment point
                    ctx.lineTo(-15, -8); // Top fin
                    ctx.lineTo(-12, -8);
                    ctx.lineTo(-8, -3);
                    ctx.closePath();
                    ctx.fill();

                    ctx.beginPath();
                    ctx.moveTo(-10, 0);  // Bottom fin
                    ctx.lineTo(-15, 8);
                    ctx.lineTo(-12, 8);
                    ctx.lineTo(-8, 3);
                    ctx.closePath();
                    ctx.fill();

                    // Nose cone gradient
                    const noseGradient = ctx.createLinearGradient(15, 0, 5, 0);
                    noseGradient.addColorStop(0, '#999');
                    noseGradient.addColorStop(1, '#666');
                    ctx.fillStyle = noseGradient;
                    ctx.beginPath();
                    ctx.moveTo(15, 0);
                    ctx.lineTo(5, -3);
                    ctx.lineTo(5, 3);
                    ctx.closePath();
                    ctx.fill();

                    // Engine fire
                    const fireGradient = ctx.createLinearGradient(-30, 0, -15, 0);
                    fireGradient.addColorStop(0, 'rgba(255, 69, 0, 0)');
                    fireGradient.addColorStop(1, 'rgba(255, 69, 0, 0.7)');
                    ctx.fillStyle = fireGradient;
                    ctx.beginPath();
                    ctx.moveTo(-15, 0);
                    ctx.lineTo(-30, -2);
                    ctx.lineTo(-30, 2);
                    ctx.closePath();
                    ctx.fill();
                }

                ctx.restore();
            }
        }

        function spawnMissile() {
            const config = levelConfig[state.level];
            const missileCount = config.missileCount;
            
            // Calculate base position
            const baseX = Math.random() * (canvas.width - 200) + 100;
            const baseY = canvas.height - 20;
            
            // Spawn multiple missiles in a spread pattern
            for (let i = 0; i < missileCount; i++) {
                state.missiles.push(new Missile(baseX, baseY, i));
            }
        }

        function damagePlayer(amount) {
            state.plane.health = Math.max(0, state.plane.health - amount);
            document.getElementById('healthFill').style.width = state.plane.health + '%';
            
            if (state.plane.health <= 0 && !state.gameOver) {
                gameOver();
            }
        }

        function gameOver(completed = false) {
            state.gameOver = true;
            document.getElementById('finalScore').textContent = state.score;
            document.getElementById('gameOver').style.display = 'block';
            if (completed) {
                document.getElementById('gameOver').innerHTML = 
                    'MISSION ACCOMPLISHED!<br>' +
                    `<span style="font-size: 24px">Final Score: ${state.score}<br>Press SPACE to play again</span>`;
            }
            showLeaderboard();
        }

        function generateTerrain() {
            const points = [];
            const segmentWidth = 50;
            const numPoints = Math.ceil(canvas.width / segmentWidth) + 1;
            
            for (let i = 0; i < numPoints; i++) {
                points.push({
                    x: i * segmentWidth,
                    height: 50 + Math.random() * 30
                });
            }
            return points;
        }

        // Balloon spawning with military targets
        function spawnBalloon() {
            const types = [
                { radius: 25, color: '#ff0000', points: 10, name: 'BALLOON' },
                { radius: 40, color: '#666666', points: 30, name: 'RADAR' },
                { radius: 35, color: '#8B4513', points: 50, name: 'BUNKER' }
            ];
            const type = types[Math.floor(Math.random() * types.length)];

            // Ensure vertical spacing between balloons
            let validPosition = false;
            let newY;
            let attempts = 0;
            const minDistance = 150; // Minimum distance between balloons

            while (!validPosition && attempts < 10) {
                newY = Math.random() * (canvas.height - 200) + 100;
                validPosition = true;

                // Check distance from existing balloons
                for (const balloon of state.balloons) {
                    const distance = Math.abs(balloon.y - newY);
                    if (distance < minDistance) {
                        validPosition = false;
                        break;
                    }
                }
                attempts++;
            }

            // If we couldn't find a good position after 10 attempts, use the last generated Y
            const balloon = {
                x: canvas.width + Math.random() * 200, // Spread out horizontally
                y: validPosition ? newY : Math.random() * (canvas.height - 200) + 100,
                ...type
            };

            state.balloons.push(balloon);
        }

        function updateBalloons() {
            // Update balloon positions
            for (let i = state.balloons.length - 1; i >= 0; i--) {
                const balloon = state.balloons[i];
                
                // Vary speed based on balloon type
                let speed = 2;
                if (balloon.points === 30) speed = 2.5;
                if (balloon.points === 50) speed = 3;
                
                balloon.x -= speed + (state.level * 0.5); // Increase speed with level

                // Remove balloons that are off screen
                if (balloon.x + balloon.radius < 0) {
                    state.balloons.splice(i, 1);
                }
            }

            // Spawn new balloons with spacing
            const minBalloons = 3 + state.level;
            const maxBalloons = 5 + state.level;
            
            if (state.balloons.length < minBalloons) {
                if (Math.random() < 0.03) { // Reduced spawn rate
                    spawnBalloon();
                }
            }
        }

        // Initialize keyboard controls (single instance)
        window.addEventListener('keydown', (e) => {
            if (state && state.keys) {
                state.keys[e.key] = true;
            }
        });
        window.addEventListener('keyup', (e) => {
            if (state && state.keys) {
                state.keys[e.key] = false;
            }
        });

        // Game loop
        let lastTime = 0;
        function gameLoop(currentTime) {
            if (!state) return;

            // Calculate delta time
            const deltaTime = (currentTime - lastTime) / 1000;
            lastTime = currentTime;

            // Clear canvases
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            radarCtx.clearRect(0, 0, radarCanvas.width, radarCanvas.height);

            // Draw background and terrain for all states
            drawBackground();
            drawTerrain();

            // Check for game over restart
            if (state.gameOver) {
                // Draw plane in crashed state
                drawPlane(state.plane.x, state.plane.y, state.plane.rotation);
                
                // Draw game over text
                ctx.fillStyle = '#ff0000';
                ctx.font = 'bold 48px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('GAME OVER', canvas.width/2, canvas.height/2);
                ctx.font = '24px Arial';
                ctx.fillText('Press SPACE to restart', canvas.width/2, canvas.height/2 + 40);
                
                // Hide game over div
                document.getElementById('gameOver').style.display = 'none';

                // Check for space bar
                if (state.keys[' ']) {
                    state = createInitialState();
                    scoreDisplay.textContent = '0';
                    levelDisplay.textContent = '1';
                    timeDisplay.textContent = '30';
                    document.getElementById('healthFill').style.width = '100%';
                }
                
                requestAnimationFrame(gameLoop);
                return;
            }

            // Rest of game logic
            if (!state.levelComplete) {
                // Update timer
                state.timeRemaining -= deltaTime;
                timeDisplay.textContent = Math.ceil(state.timeRemaining);

                if (state.timeRemaining <= 0) {
                    completeLevel();
                }

                // Update missile spawn
                const config = levelConfig[state.level];
                state.missileSpawnTimer++;
                if (state.missileSpawnTimer > config.missileInterval) {
                    spawnMissile();
                    state.missileSpawnTimer = 0;
                }

                // Update plane position
                if (state.keys['w'] && state.plane.targetY > 100) {
                    state.plane.targetY -= 10;
                }
                if (state.keys['s'] && state.plane.targetY < canvas.height - 100) {
                    state.plane.targetY += 10;
                }
                if (state.keys['a'] && state.plane.targetX > 100) {
                    state.plane.targetX -= 10;
                    state.plane.rotation = -0.2;
                }
                if (state.keys['d'] && state.plane.targetX < canvas.width - 100) {
                    state.plane.targetX += 10;
                    state.plane.rotation = 0.2;
                }
                if (!state.keys['a'] && !state.keys['d']) {
                    state.plane.rotation = 0;
                }

                // Smooth plane movement
                const dx = state.plane.targetX - state.plane.x;
                const dy = state.plane.targetY - state.plane.y;
                state.plane.x += dx * 0.1;
                state.plane.y += dy * 0.1;

                // Move game objects
                state.missiles.forEach(missile => missile.update());
                state.missiles = state.missiles.filter(missile => missile.active);

                updateBalloons();

                state.clouds.forEach(cloud => {
                    cloud.x -= cloud.speed;
                    if (cloud.x < -100) {
                        cloud.x = canvas.width + 100;
                        cloud.y = Math.random() * (canvas.height / 2);
                    }
                });

                // Check collisions
                checkCollisions();
            }

            // Draw game objects
            state.clouds.forEach(cloud => drawCloud(cloud.x, cloud.y, cloud.size));
            state.balloons.forEach(balloon => drawTarget(balloon.x, balloon.y, balloon.radius, balloon.color));
            state.missiles.forEach(missile => missile.draw());
            drawPlane(state.plane.x, state.plane.y, state.plane.rotation);
            drawEffects();
            drawRadar();

            // Update health bar
            const healthPercent = (state.plane.health / 100) * 100;
            document.getElementById('healthFill').style.width = healthPercent + '%';

            // Continue game loop
            requestAnimationFrame(gameLoop);
        }

        function checkCollisions() {
            // Check missile-balloon collisions
            state.missiles.forEach(missile => {
                state.balloons.forEach((balloon, index) => {
                    const dx = missile.x - balloon.x;
                    const dy = missile.y - balloon.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance < balloon.radius + 5) {
                        state.score += balloon.points;
                        state.balloons.splice(index, 1);
                        missile.active = false;
                        createExplosion(balloon.x, balloon.y);
                    }
                });
            });

            // Check plane-balloon collisions
            state.balloons.forEach((balloon, index) => {
                const dx = state.plane.x - balloon.x;
                const dy = state.plane.y - balloon.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance < balloon.radius + 20) {
                    state.plane.health -= 25;
                    state.balloons.splice(index, 1);
                    createExplosion(balloon.x, balloon.y);
                    
                    if (state.plane.health <= 0) {
                        state.gameOver = true;
                        showLeaderboard();
                    }
                }
            });
        }

        // Draw background with layered forest style
        function drawBackground() {
            // Sky gradient (cyan to light cyan)
            const skyGradient = ctx.createLinearGradient(0, 0, 0, canvas.height * 0.7);
            skyGradient.addColorStop(0, '#40E0FF');   // Bright cyan
            skyGradient.addColorStop(0.5, '#7FFFFF'); // Light cyan
            skyGradient.addColorStop(1, '#BFFFEF');   // Very light cyan
            ctx.fillStyle = skyGradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw sun rays
            ctx.save();
            ctx.globalAlpha = 0.1;
            for (let i = 0; i < 12; i++) {
                const angle = (i / 12) * Math.PI * 2;
                const x = canvas.width * 0.8;
                const y = canvas.height * 0.2;
                ctx.beginPath();
                ctx.moveTo(x, y);
                ctx.lineTo(x + Math.cos(angle) * canvas.width, y + Math.sin(angle) * canvas.width);
                ctx.strokeStyle = '#FFE87C';
                ctx.lineWidth = 50;
                ctx.stroke();
            }
            ctx.restore();

            // Draw distant hills (3 layers)
            const hillColors = ['#4F7942', '#3B5B33', '#2D4A25'];
            const hillHeights = [0.65, 0.7, 0.75];
            
            hillColors.forEach((color, i) => {
                ctx.fillStyle = color;
                ctx.beginPath();
                ctx.moveTo(0, canvas.height * hillHeights[i]);
                
                // Create smooth hill curves
                let x = 0;
                while (x < canvas.width) {
                    const height = Math.sin(x * 0.001) * 50 + 
                                 Math.sin(x * 0.002) * 30 +
                                 Math.sin(x * 0.004) * 20;
                    ctx.lineTo(x, canvas.height * hillHeights[i] + height);
                    x += 10;
                }
                
                ctx.lineTo(canvas.width, canvas.height);
                ctx.lineTo(0, canvas.height);
                ctx.fill();
            });

            // Draw forest layers (5 layers)
            const forestColors = [
                '#1B4D2B', // Darkest back
                '#2D5A4E',
                '#2F6E31',
                '#3C8C40',
                '#4CA349'  // Lightest front
            ];
            
            const baseHeights = [0.6, 0.65, 0.7, 0.75, 0.8];
            
            forestColors.forEach((color, i) => {
                const baseHeight = canvas.height * baseHeights[i];
                ctx.fillStyle = color;
                
                // Draw tree line for this layer
                ctx.beginPath();
                ctx.moveTo(0, baseHeight);
                
                // Create natural tree shapes
                for (let x = 0; x < canvas.width; x += 40) {
                    const treeHeight = 80 + Math.sin(x * 0.02) * 20;
                    const treeWidth = 60 + Math.cos(x * 0.02) * 10;
                    
                    // Tree crown (rounded shape)
                    ctx.lineTo(x, baseHeight);
                    
                    // Left side of tree
                    ctx.bezierCurveTo(
                        x, baseHeight,
                        x - treeWidth/3, baseHeight - treeHeight/3,
                        x, baseHeight - treeHeight
                    );
                    
                    // Top of tree
                    ctx.bezierCurveTo(
                        x, baseHeight - treeHeight,
                        x + treeWidth/2, baseHeight - treeHeight - 10,
                        x + treeWidth, baseHeight - treeHeight
                    );
                    
                    // Right side of tree
                    ctx.bezierCurveTo(
                        x + treeWidth, baseHeight - treeHeight,
                        x + treeWidth + treeWidth/3, baseHeight - treeHeight/3,
                        x + treeWidth, baseHeight
                    );
                }
                
                ctx.lineTo(canvas.width, canvas.height);
                ctx.lineTo(0, canvas.height);
                ctx.fill();

                // Add detail shadows for depth
                ctx.fillStyle = adjustColor(color, -20);
                for (let x = 0; x < canvas.width; x += 40) {
                    const treeHeight = 80 + Math.sin(x * 0.02) * 20;
                    const treeWidth = 60 + Math.cos(x * 0.02) * 10;
                    
                    ctx.beginPath();
                    ctx.moveTo(x + treeWidth/2, baseHeight);
                    ctx.bezierCurveTo(
                        x + treeWidth/2, baseHeight - treeHeight/3,
                        x + treeWidth/2 + 10, baseHeight - treeHeight/2,
                        x + treeWidth/2, baseHeight - treeHeight + 10
                    );
                    ctx.bezierCurveTo(
                        x + treeWidth/2, baseHeight - treeHeight + 10,
                        x + treeWidth/2 + 20, baseHeight - treeHeight/2,
                        x + treeWidth/2 + 15, baseHeight
                    );
                    ctx.fill();
                }
            });

            // Helper function to darken/lighten colors
            function adjustColor(color, amount) {
                const hex = color.replace('#', '');
                const num = parseInt(hex, 16);
                const r = Math.min(255, Math.max(0, (num >> 16) + amount));
                const g = Math.min(255, Math.max(0, ((num >> 8) & 0x00FF) + amount));
                const b = Math.min(255, Math.max(0, (num & 0x0000FF) + amount));
                return '#' + (g | (b << 8) | (r << 16)).toString(16).padStart(6, '0');
            }

            // Draw ground layers
            const groundColors = ['#90B77D', '#708B61', '#42593F'];
            const groundHeights = [0.85, 0.9, 0.95];
            
            groundColors.forEach((color, i) => {
                ctx.fillStyle = color;
                ctx.beginPath();
                ctx.moveTo(0, canvas.height * groundHeights[i]);
                
                // Create detailed ground with small variations
                let x = 0;
                while (x < canvas.width) {
                    const height = Math.sin(x * 0.05) * 5 + 
                                 Math.random() * 3;
                    ctx.lineTo(x, canvas.height * groundHeights[i] + height);
                    x += 10;
                }
                
                ctx.lineTo(canvas.width, canvas.height);
                ctx.lineTo(0, canvas.height);
                ctx.fill();

                // Add grass details
                if (i === 0) {
                    ctx.strokeStyle = '#A6C298';
                    ctx.lineWidth = 1;
                    for (let x = 0; x < canvas.width; x += 15) {
                        ctx.beginPath();
                        ctx.moveTo(x, canvas.height * groundHeights[i]);
                        ctx.lineTo(x + Math.random() * 10 - 5, canvas.height * groundHeights[i] - 10 - Math.random() * 10);
                        ctx.stroke();
                    }
                }
            });

            // Add some rocks in the foreground
            const rockPositions = [100, 300, 600, 800, 1100];
            rockPositions.forEach(x => {
                ctx.fillStyle = '#808080';
                ctx.beginPath();
                ctx.moveTo(x, canvas.height * 0.85);
                ctx.quadraticCurveTo(x + 15, canvas.height * 0.82, x + 30, canvas.height * 0.85);
                ctx.fill();
            });
        }

        // Draw terrain with more detail
        function drawTerrain() {
            // Multi-layer ground
            const layers = [
                { offset: 0.75, color: '#1a472a', detail: 20 },
                { offset: 0.8, color: '#2d5a4c', detail: 15 },
                { offset: 0.85, color: '#234d3d', detail: 10 }
            ];

            layers.forEach(layer => {
                const groundGradient = ctx.createLinearGradient(0, canvas.height * layer.offset, 0, canvas.height);
                groundGradient.addColorStop(0, layer.color);
                groundGradient.addColorStop(1, '#0B2B26');
                ctx.fillStyle = groundGradient;
                
                ctx.beginPath();
                ctx.moveTo(0, canvas.height);
                ctx.lineTo(0, canvas.height * layer.offset);
                
                // Create detailed terrain pattern
                let x = 0;
                while (x < canvas.width) {
                    const noise = Math.sin(x * 0.02) * layer.detail + 
                                Math.sin(x * 0.05) * (layer.detail * 0.5) +
                                Math.random() * (layer.detail * 0.3);
                    ctx.lineTo(x, canvas.height * layer.offset + noise);
                    x += 10;
                }
                
                ctx.lineTo(canvas.width, canvas.height);
                ctx.closePath();
                ctx.fill();

                // Add terrain texture
                ctx.strokeStyle = `${layer.color}88`;
                ctx.lineWidth = 1;
                for (let y = canvas.height * layer.offset; y < canvas.height; y += 10) {
                    ctx.beginPath();
                    ctx.moveTo(0, y);
                    for (let x = 0; x < canvas.width; x += 15) {
                        ctx.lineTo(x + Math.random() * 10, y + Math.random() * 5 - 2.5);
                    }
                    ctx.stroke();
                }
            });
        }

        // Enhanced cloud drawing
        function drawCloud(x, y, size) {
            ctx.save();
            ctx.translate(x, y);

            // Create complex cloud shape with multiple gradients
            const positions = [
                { x: 0, y: 0, size: size, opacity: 0.9 },
                { x: -size * 0.5, y: size * 0.1, size: size * 0.7, opacity: 0.8 },
                { x: size * 0.5, y: size * 0.1, size: size * 0.7, opacity: 0.8 },
                { x: -size * 0.2, y: -size * 0.3, size: size * 0.6, opacity: 0.7 },
                { x: size * 0.2, y: -size * 0.3, size: size * 0.6, opacity: 0.7 },
                { x: 0, y: size * 0.2, size: size * 0.8, opacity: 0.8 }
            ];

            // Draw cloud parts with gradients
            positions.forEach(pos => {
                const gradient = ctx.createRadialGradient(
                    pos.x, pos.y, 0,
                    pos.x, pos.y, pos.size
                );
                gradient.addColorStop(0, `rgba(255, 255, 255, ${pos.opacity})`);
                gradient.addColorStop(0.5, `rgba(255, 255, 255, ${pos.opacity * 0.7})`);
                gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');

                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(pos.x, pos.y, pos.size, 0, Math.PI * 2);
                ctx.fill();
            });

            // Add highlight
            const highlightGradient = ctx.createRadialGradient(
                -size * 0.2, -size * 0.2, 0,
                -size * 0.2, -size * 0.2, size * 0.8
            );
            highlightGradient.addColorStop(0, 'rgba(255, 255, 255, 0.4)');
            highlightGradient.addColorStop(0.5, 'rgba(255, 255, 255, 0.1)');
            highlightGradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
            ctx.fillStyle = highlightGradient;
            ctx.beginPath();
            ctx.arc(-size * 0.2, -size * 0.2, size * 0.8, 0, Math.PI * 2);
            ctx.fill();

            ctx.restore();
        }

        // Draw radar display
        function drawRadar() {
            radarCtx.fillStyle = 'rgba(0, 32, 0, 0.7)';
            radarCtx.fillRect(0, 0, radarCanvas.width, radarCanvas.height);

            // Draw radar sweep
            const time = Date.now() / 1000;
            const angle = (time % 2) * Math.PI;
            
            radarCtx.strokeStyle = '#0f0';
            radarCtx.lineWidth = 2;
            
            // Draw radar circles
            for (let r = 1; r <= 4; r++) {
                radarCtx.beginPath();
                radarCtx.arc(100, 100, r * 25, 0, Math.PI * 2);
                radarCtx.stroke();
            }
            
            // Draw sweep line
            radarCtx.beginPath();
            radarCtx.moveTo(100, 100);
            radarCtx.lineTo(
                100 + Math.cos(angle) * 100,
                100 + Math.sin(angle) * 100
            );
            radarCtx.stroke();
            
            // Draw targets on radar
            state.balloons.forEach(balloon => {
                const dx = (balloon.x - state.plane.x) / 10;
                const dy = (balloon.y - state.plane.y) / 10;
                
                if (Math.abs(dx) < 100 && Math.abs(dy) < 100) {
                    radarCtx.fillStyle = '#0f0';
                    radarCtx.beginPath();
                    radarCtx.arc(100 + dx, 100 + dy, 2, 0, Math.PI * 2);
                    radarCtx.fill();
                }
            });

            // Draw missiles on radar
            state.missiles.forEach(missile => {
                if (!missile.warning) {
                    const dx = (missile.x - state.plane.x) / 10;
                    const dy = (missile.y - state.plane.y) / 10;
                    
                    if (Math.abs(dx) < 100 && Math.abs(dy) < 100) {
                        radarCtx.fillStyle = '#f00';
                        radarCtx.beginPath();
                        radarCtx.arc(100 + dx, 100 + dy, 2, 0, Math.PI * 2);
                        radarCtx.fill();
                    }
                }
            });
        }

        // Draw airplane with enhanced detail
        function drawPlane(x, y, rotation) {
            ctx.save();
            ctx.translate(x, y);
            ctx.rotate(rotation);

            const scale = 1.75; // Middle ground size
            
            // Main body (fuselage)
            ctx.fillStyle = '#2C3E50';
            ctx.fillRect(-30 * scale, -8 * scale, 60 * scale, 16 * scale);
            
            // Nose cone
            ctx.beginPath();
            ctx.moveTo(30 * scale, 0);
            ctx.lineTo(40 * scale, -4 * scale);
            ctx.lineTo(40 * scale, 4 * scale);
            ctx.fillStyle = '#E74C3C';
            ctx.fill();

            // Cockpit
            ctx.fillStyle = '#3498DB';
            ctx.fillRect(5 * scale, -6 * scale, 15 * scale, 12 * scale);
            
            // Cockpit highlight
            ctx.fillStyle = '#85C1E9';
            ctx.fillRect(7 * scale, -4 * scale, 11 * scale, 8 * scale);

            // Wings
            ctx.fillStyle = '#7F8C8D';
            // Main wings
            ctx.beginPath();
            ctx.moveTo(-20 * scale, -8 * scale);
            ctx.lineTo(-10 * scale, -30 * scale);
            ctx.lineTo(20 * scale, -30 * scale);
            ctx.lineTo(30 * scale, -8 * scale);
            ctx.fill();
            
            ctx.beginPath();
            ctx.moveTo(-20 * scale, 8 * scale);
            ctx.lineTo(-10 * scale, 30 * scale);
            ctx.lineTo(20 * scale, 30 * scale);
            ctx.lineTo(30 * scale, 8 * scale);
            ctx.fill();

            // Tail wings
            ctx.beginPath();
            ctx.moveTo(-25 * scale, -5 * scale);
            ctx.lineTo(-30 * scale, -15 * scale);
            ctx.lineTo(-20 * scale, -15 * scale);
            ctx.lineTo(-15 * scale, -5 * scale);
            ctx.fill();

            ctx.beginPath();
            ctx.moveTo(-25 * scale, 5 * scale);
            ctx.lineTo(-30 * scale, 15 * scale);
            ctx.lineTo(-20 * scale, 15 * scale);
            ctx.lineTo(-15 * scale, 5 * scale);
            ctx.fill();

            // Vertical stabilizer
            ctx.beginPath();
            ctx.moveTo(-30 * scale, -4 * scale);
            ctx.lineTo(-35 * scale, -20 * scale);
            ctx.lineTo(-25 * scale, -20 * scale);
            ctx.lineTo(-20 * scale, -4 * scale);
            ctx.fill();

            // Engine details
            ctx.fillStyle = '#95A5A6';
            ctx.fillRect(-15 * scale, -25 * scale, 10 * scale, 5 * scale);
            ctx.fillRect(-15 * scale, 20 * scale, 10 * scale, 5 * scale);

            // Exhaust effect
            if (Math.random() > 0.5) {
                ctx.fillStyle = '#E74C3C';
                ctx.fillRect(-35 * scale, -2 * scale, 5 * scale, 4 * scale);
            } else {
                ctx.fillStyle = '#F1C40F';
                ctx.fillRect(-35 * scale, -2 * scale, 5 * scale, 4 * scale);
            }

            ctx.restore();
        }

        // Draw effects
        function drawEffects() {
            state.effects = state.effects.filter(effect => {
                effect.age++;
                effect.radius = (effect.age / effect.maxAge) * effect.maxRadius;
                
                // Draw explosion
                const alpha = 1 - (effect.age / effect.maxAge);
                ctx.strokeStyle = `rgba(255, ${Math.floor(165 * alpha)}, 0, ${alpha})`;
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.arc(effect.x, effect.y, effect.radius, 0, Math.PI * 2);
                ctx.stroke();
                
                return effect.age < effect.maxAge;
            });
        }

        function completeLevel() {
            if (state.level < 5) {
                state.levelComplete = true;
                document.getElementById('nextLevel').textContent = state.level + 1;
                document.getElementById('levelComplete').style.display = 'block';
                setTimeout(() => {
                    document.getElementById('levelComplete').style.display = 'none';
                    startLevel(state.level + 1);
                }, 3000);
            } else {
                // Game completed
                gameOver(true);
            }
        }

        function startLevel(level) {
            state.level = level;
            state.timeRemaining = 30;
            state.levelComplete = false;
            state.plane.health = 100;
            state.missiles = [];
            state.balloons = [];
            state.effects = [];
            state.plane.y = canvas.height / 2;
            state.plane.targetY = canvas.height / 2;
            generateTerrain();
            document.getElementById('healthFill').style.width = '100%';
            levelDisplay.textContent = level;
            
            // Spawn initial balloons for the level
            const config = levelConfig[level];
            for (let i = 0; i < config.balloonCount; i++) {
                spawnBalloon();
            }
        }

        // Initialize the game
        function initGame() {
            gameContainer.style.display = 'block';
            resetGame();
            lastTime = performance.now();
            requestAnimationFrame(gameLoop);
        }

        // Start button click handler
        startButton.addEventListener('click', () => {
            loadingScreen.style.display = 'none';
            initGame();
        });

        function damagePlayer(amount) {
            state.plane.health = Math.max(0, state.plane.health - amount);
            if (state.plane.health <= 0) {
                state.gameOver = true;
            }
        }

        // Draw target (balloon)
        function drawTarget(x, y, radius, color) {
            ctx.save();
            ctx.translate(x, y);

            // Simple shadow
            ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
            ctx.beginPath();
            ctx.ellipse(radius * 0.3, radius * 0.3, radius * 0.7, radius * 0.1, 0, 0, Math.PI * 2);
            ctx.fill();

            // Main balloon body (pixel style circle)
            const baseColor = color;
            const highlightColor = color === '#ff0000' ? '#ff6666' : 
                                 color === '#666666' ? '#999999' : 
                                 '#b27341';
            const shadowColor = color === '#ff0000' ? '#cc0000' : 
                              color === '#666666' ? '#444444' : 
                              '#8B4513';

            // Draw main circle using small rectangles for pixel effect
            const pixelSize = radius * 0.2;
            const circlePoints = [];
            
            // Generate points for a circle
            for (let angle = 0; angle < Math.PI * 2; angle += Math.PI / 16) {
                const px = Math.round(Math.cos(angle) * radius / pixelSize) * pixelSize;
                const py = Math.round(Math.sin(angle) * radius / pixelSize) * pixelSize;
                circlePoints.push({x: px, y: py});
            }

            // Fill the circle
            ctx.fillStyle = baseColor;
            for (let px = -radius; px < radius; px += pixelSize) {
                for (let py = -radius; py < radius; py += pixelSize) {
                    if (px * px + py * py <= radius * radius) {
                        ctx.fillRect(px, py, pixelSize, pixelSize);
                    }
                }
            }

            // Add pixel highlights (top-left quadrant)
            ctx.fillStyle = highlightColor;
            for (let px = -radius; px < 0; px += pixelSize) {
                for (let py = -radius; py < 0; py += pixelSize) {
                    if (px * px + py * py <= radius * radius * 0.7 &&
                        px * px + py * py >= radius * radius * 0.3) {
                        ctx.fillRect(px, py, pixelSize, pixelSize);
                    }
                }
            }

            // Add pixel shadows (bottom-right quadrant)
            ctx.fillStyle = shadowColor;
            for (let px = 0; px < radius; px += pixelSize) {
                for (let py = 0; py < radius; py += pixelSize) {
                    if (px * px + py * py <= radius * radius * 0.7 &&
                        px * px + py * py >= radius * radius * 0.3) {
                        ctx.fillRect(px, py, pixelSize, pixelSize);
                    }
                }
            }

            // Draw knot (3x3 pixels)
            ctx.fillStyle = shadowColor;
            ctx.beginPath();
            ctx.moveTo(-radius * 0.15, radius);
            ctx.quadraticCurveTo(-radius * 0.15 + 15, radius + 15, -radius * 0.15 + 30, radius);
            ctx.fill();
            ctx.fillRect(-radius * 0.15, radius, radius * 0.3, radius * 0.3);

            // Draw string (pixel by pixel)
            ctx.fillStyle = '#000000';
            let stringY = radius * 1.4;
            
            for (let i = 0; i < 8; i++) {
                // Alternate string position for pixelated zigzag
                const stringX = (i % 2) * radius * 0.1;
                ctx.fillRect(stringX - radius * 0.05, stringY, radius * 0.1, radius * 0.2);
                stringY += radius * 0.2;
            }

            ctx.restore();
        }

        // Create explosion effect
        function createExplosion(x, y) {
            state.effects.push({
                x, y,
                radius: 1,
                maxRadius: 40,
                age: 0,
                maxAge: 20
            });
        }

        async function submitScore() {
            const initials = document.getElementById('initials').value.toUpperCase();
            if (initials.length !== 3) {
                alert('Please enter exactly 3 characters for your initials');
                return;
            }

            try {
                const response = await fetch('/api/scores', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        initials: initials,
                        score: state.score,
                        level: state.level
                    })
                });

                if (response.ok) {
                    loadLeaderboard();
                } else {
                    alert('Error submitting score. Please try again.');
                }
            } catch (error) {
                console.error('Error:', error);
                alert('Error submitting score. Please try again.');
            }
        }

        async function loadLeaderboard() {
            try {
                const response = await fetch('/api/scores');
                const scores = await response.json();
                
                const tbody = document.getElementById('scoresTable');
                tbody.innerHTML = '';
                
                scores.forEach((score, index) => {
                    const row = tbody.insertRow();
                    row.insertCell(0).textContent = index + 1;
                    row.insertCell(1).textContent = score.initials;
                    row.insertCell(2).textContent = score.score;
                    row.insertCell(3).textContent = score.level;
                });
            } catch (error) {
                console.error('Error loading leaderboard:', error);
            }
        }

        function showLeaderboard() {
            document.getElementById('finalScore').textContent = state.score;
            document.getElementById('finalLevel').textContent = state.level;
            document.getElementById('leaderboard').style.display = 'block';
            loadLeaderboard();
        }

        function restartGame() {
            document.getElementById('leaderboard').style.display = 'none';
            initGame();
            gameLoop();
        }

        function checkGameOver() {
            if (state.health <= 0) {
                state.gameOver = true;
                showLeaderboard();
            }
        }
    </script>
</body>
</html>
